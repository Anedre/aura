// src/app/(authed)/home/page.tsx"use client";import { useEffect, useMemo, useState } from "react";import { useRouter } from "next/navigation";import { loadRiskProfile } from "@/lib/invest";import MarketChartE from "@/components/MarketChartE";import PriceTicker from "@/components/PriceTicker";import SymbolAvatar from "@/components/SymbolAvatar";import { classifySymbol, type AssetClass } from "@/lib/market";import { getAssetMeta } from "@/lib/assets.meta";// import type { RangeBtn } from "@/components/MarketChartE"; // Si prefieres reutilizar fetchJSON desde lib/market, puedes importarlo:// import { fetchJSON } from "@/lib/market";type Horizon = "1d" | "1w";type Action = "BUY" | "SELL" | "HOLD" | "ABSTAIN";type FeedItem = {  symbol: string;  ts?: string;  action: Action;  p_conf?: number;  sigma?: number;  horizon?: string;  last_close?: number;  stops?: { tp: number; sl: number } | null;  quality?: number;};const API_BASE = (process.env.NEXT_PUBLIC_API_BASE || "").replace(/\/+$/, "");// -------- utilidades presentación --------function actionLabel(a: Action) {  if (a === "BUY") return "Sube";  if (a === "SELL") return "Baja";  if (a === "HOLD") return "En espera";  return "Sin señal clara";}function horizonLabel(h: Horizon) {  return h === "1w" ? "Próximas semanas" : "Próximos días";}// -------- helpers de red --------async function fetchJSON<T>(url: string, init?: RequestInit): Promise<T> {  const r = await fetch(url, { ...init, cache: "no-store" });  if (!r.ok) throw new Error(`HTTP ${r.status}`);  return (await r.json()) as T;}type StopsRaw = { tp?: unknown; sl?: unknown };function parseStops(x: unknown): { tp: number; sl: number } | null {  if (typeof x !== "object" || x === null) return null;  const o = x as StopsRaw;  const tp = typeof o.tp === "number" ? o.tp : Number.NaN;  const sl = typeof o.sl === "number" ? o.sl : Number.NaN;  if (Number.isNaN(tp) || Number.isNaN(sl)) return null;  return { tp, sl };}async function getFeed(h: Horizon, minConf: number): Promise<FeedItem[]> {  if (!API_BASE) return [];  const qs = new URLSearchParams({ horizon: h, min_conf: String(minConf), limit: "200" });  const data = await fetchJSON<unknown>(`${API_BASE}/v1/feed?${qs.toString()}`);  if (!Array.isArray(data)) return [];  return data    .map((x) => {      const o = x as Record<string, unknown>;      return {        symbol: String(o.symbol ?? ""),        ts: typeof o.ts === "string" ? o.ts : undefined,        action: (["BUY", "SELL", "HOLD", "ABSTAIN"].includes(String(o.action)) ? String(o.action) : "HOLD") as Action,        p_conf: typeof o.p_conf === "number" ? o.p_conf : undefined,        sigma: typeof o.sigma === "number" ? o.sigma : undefined,        horizon: typeof o.horizon === "string" ? o.horizon : undefined,        last_close: typeof o.last_close === "number" ? o.last_close : undefined,        stops: parseStops(o.stops),        quality: typeof o.quality === "number" ? o.quality : undefined,      } satisfies FeedItem;    })    .filter((x) => x.symbol);}// ================== HOME ==================export default function HomePage() {  const router = useRouter();  const defaults = useMemo(() => {    const p = loadRiskProfile()?.profile;    if (p === "Conservador") return { horizon: "1d" as Horizon, minConf: 0.65 };    if (p === "Agresivo")   return { horizon: "1d" as Horizon, minConf: 0.55 };    return { horizon: "1d" as Horizon, minConf: 0.60 };  }, []);  const [horizon, setHorizon] = useState<Horizon>(defaults.horizon);  const [minConf, setMinConf] = useState<number>(defaults.minConf);  const [feed, setFeed] = useState<FeedItem[] | null>(null);  const [error, setError] = useState<string | null>(null);  const [updatedAt, setUpdatedAt] = useState<Date | null>(null);  const [pinned, setPinned] = useState<string[]>([]);  const [focus, setFocus] = useState<string | null>(null);  const [showHelp, setShowHelp] = useState<boolean>(true);  const [filterClass, setFilterClass] = useState<AssetClass | 'all'>("all");    // estados para el indicador  const [rangeDelta, setRangeDelta] = useState<number | null>(null);  // carga/refresh del feed  useEffect(() => {    let alive = true;    async function load() {      try {        setError(null);        const data = await getFeed(horizon, minConf);        if (!alive) return;        setFeed(data);        setUpdatedAt(new Date());        // seleccionar símbolo por defecto (mejor certeza != ABSTAIN)        if (!focus) {          const fav = (() => { try { return localStorage.getItem('aura_favorite_asset'); } catch { return null; } })();          if (fav) {            setFocus(fav);            setPinned((p) => (p.includes(fav) ? p : [fav, ...p].slice(0, 6)));          } else {            const best = data              .filter((d: FeedItem) => d.action !== "ABSTAIN")              .sort((a, b) => (b.p_conf ?? 0) - (a.p_conf ?? 0))[0];            if (best) {              setFocus(best.symbol);              setPinned((p) => (p.includes(best.symbol) ? p : [best.symbol, ...p].slice(0, 6)));            }          }        }      } catch (e) {        setError(e instanceof Error ? e.message : "No se pudo cargar el feed");      }    }    void load();    const id = setInterval(load, 90_000);    return () => { alive = false; clearInterval(id); };  }, [horizon, minConf, focus]);  // Cargar preferencia por defecto de clase (perfil)  useEffect(() => {    try {      const pref = localStorage.getItem('aura_pref_class') as (AssetClass | 'all') | null;      if (pref) setFilterClass(pref);    } catch { /* noop */ }  }, []);  const current = useMemo(() => {    if (!feed || !focus) return null;    return feed.find((x) => x.symbol === focus) ?? null;  }, [feed, focus]);  const selectedMeta = useMemo(() => (assetSymbol ? getAssetMeta(assetSymbol) : null), [/* eslint-disable-line */]);  const [lastPrice, setLastPrice] = useState<number | null>(null);  const projection = useMemo<number | null>(() => {    const base = (lastPrice ?? current?.last_close ?? null);    if (!current || base == null || !Number.isFinite(base)) return null;    const tp = current.stops && typeof current.stops.tp === 'number' ? current.stops.tp : null;    if (tp != null && Number.isFinite(tp)) return tp;    const conf = Math.max(0, Math.min(1, current.p_conf ?? 0.6));    const sign = current.action === 'SELL' ? -1 : current.action === 'BUY' ? 1 : 0;    if (sign === 0) return null;    const step = 0.01 * conf;    return base * (1 + sign * step);  }, [current, lastPrice]);  // Deriva el símbolo desde tu selección actual (ajusta a tu estado real)  const assetSymbol = useMemo<string | null>(() => {    // casos típicos: current?.symbol viene de tu store/selección;    // focus podría venir del search o url.    if (current?.symbol && typeof current.symbol === 'string') return current.symbol;    if (typeof focus === 'string' && focus.length > 0) return focus;    return null; // SIN fallback. Si es null, no renderizamos el gráfico.  }, [current?.symbol, focus]);  const confPct = current?.p_conf != null ? Math.round(current.p_conf * 100) : null;  function togglePin(sym: string) {    setPinned((p) => (p.includes(sym) ? p.filter((s) => s !== sym) : [sym, ...p].slice(0, 6)));  }  return (    <main className="min-h-dvh bg-background text-foreground">      <div className="max-w-6xl mx-auto px-6 py-8 space-y-8">        <header className="flex flex-wrap items-center gap-4 justify-between">          <div>            <h1 className="text-3xl font-bold tracking-tight">Para ti</h1>            <p className="text-sm opacity-70">Las mejores recomendaciones, ordenadas para tu perfil.</p>          </div>          <div className="flex items-center gap-2">            <select              value={horizon}              onChange={(e) => setHorizon(e.target.value as Horizon)}              className="toolbar"              title="Periodo"            >              <option value="1d">Próximo cierre (1 día)</option>              <option value="1w">Próximas semanas</option>            </select>            <div className="toolbar">              <label className="text-xs opacity-80 mr-2">Certeza mínima</label>              <input                type="range"                min={10}                max={80}                value={Math.round(minConf * 100)}                onChange={(e) => setMinConf(Number(e.target.value) / 100)}              />              <span className="ml-2 text-xs font-medium">{Math.round(minConf * 100)}%</span>            </div>            {showHelp && (              <div className="card p-4">                <div className="text-sm opacity-80 mb-1">¿Qué hago ahora?</div>                <ul className="text-xs opacity-80 list-disc pl-4 space-y-1">                  <li>“Probar inversión” te deja jugar con montos y tiempo.</li>                  <li>“Enviar solicitud” pide una predicción diaria personalizada.</li>                  <li>“Mi perfil” guarda tus preferencias para ajustar la vista.</li>                </ul>              </div>            )}            <button              className={`btn ${showHelp ? 'btn-primary' : ''}`}              onClick={() => setShowHelp(v => !v)}              title="Mostrar/ocultar explicaciones"            >              {showHelp ? 'Modo explicado: ON' : 'Modo explicado: OFF'}            </button>            <div className="toolbar">              <label className="text-xs opacity-80 mr-2">Clase</label>              <select                value={filterClass}                onChange={(e) => setFilterClass(e.currentTarget.value as AssetClass | 'all')}                className="bg-transparent"              >                <option value="all">Todas</option>                <option value="crypto">Cripto</option>                <option value="forex">Forex</option>                <option value="equity">Acciones</option>                <option value="etf">ETF</option>                <option value="index">Índices</option>              </select>              {filterClass !== 'all' && (                <button className="ml-2 btn" onClick={() => setFilterClass('all')} title="Quitar filtro">Quitar filtro</button>              )}            </div>            <button className="btn" onClick={() => router.push("/feed")}>Ver todo</button>          </div>        </header>        {showHelp && (          <div className="rounded-xl border border-white/10 bg-white/[0.04] p-4 text-sm">            <div className="font-semibold mb-1">Cómo usar esta pantalla</div>            <div className="grid sm:grid-cols-3 gap-3">              <div className="rounded-lg border border-white/10 p-2">                <div className="text-xs opacity-70 mb-1">Paso 1</div>                Elige un activo de la lista. Verás una señal (sube/baja/espera) y su certeza.              </div>              <div className="rounded-lg border border-white/10 p-2">                <div className="text-xs opacity-70 mb-1">Paso 2</div>                Mira el gráfico y el precio en vivo. Si te interesa, fíjalo para tenerlo a mano.              </div>              <div className="rounded-lg border border-white/10 p-2">                <div className="text-xs opacity-70 mb-1">Paso 3</div>                Prueba la idea en el simulador o pide una predicción para el próximo cierre.              </div>            </div>          </div>        )}        <section className="grid lg:grid-cols-3 gap-5">          <div className="lg:col-span-2">            <div className="card p-4">              <div className="flex items-center justify-between mb-3">                <div className="flex items-center gap-3">                  <div className="text-2xl font-semibold flex items-center gap-2">                    {assetSymbol ? (<><SymbolAvatar symbol={assetSymbol} size={20} /><span>{assetSymbol}</span></>) : ("-")}                  </div>                  <PriceTicker symbol={assetSymbol ?? undefined} price={lastPrice} deltaPct={rangeDelta ?? null} className="ml-2" updateEveryMs={3000} />                  {current && <span className="chip">{actionLabel(current.action)}</span>}                  {confPct != null && <span className="chip">{confPct}% certeza</span>}                  {current?.horizon && (                    <span className="chip">{horizonLabel((current.horizon as Horizon) || "1d")}</span>                  )}                </div>                {selectedMeta && (                  <div className="text-xs opacity-75 mt-1">{selectedMeta.name}</div>                )}                <div className="flex items-center gap-2">                  {current && (                    <button                      className={`btn ${pinned.includes(current.symbol) ? "btn-primary" : ""}`}                      onClick={() => togglePin(current.symbol)}                    >                      {pinned.includes(current.symbol) ? "Fijado" : "Fijar"}                    </button>                  )}                </div>              </div>              {showHelp && (                <div className="mb-3 text-xs opacity-80">                  ¿Qué significa? &quot;Sube/Baja&quot; describe la dirección más probable para el próximo <span className="tech-term">cierre<div className="tech-term__tooltip"><div className="tech-term__title">Cierre de operaciones</div><div className="tech-term__body">Momento en que termina la sesión regular del mercado.</div><div className="tech-term__applies">Uso: define ventanas de evaluación (diario/semanal).</div></div></span>. La <span className="tech-term">certeza<div className="tech-term__tooltip"><div className="tech-term__title">Certeza</div><div className="tech-term__body">Nivel estimado de confianza de una predicción.</div><div className="tech-term__applies">Uso: ajusta expectativas y riesgo.</div></div></span> es una estimación.                </div>              )}              {/* === Gráfico en tiempo real reutilizable === */}             {assetSymbol ? (                <>                <MarketChartE                  symbol={assetSymbol}                  provider="auto"                  tf="5m"                  height={440}                  baseline={projection ?? null}                  showLastPrice                  onPrice={setLastPrice}                  onRangeDelta={(d) => { setRangeDelta(d); }}                />                {projection != null && (                  <div className="mt-2 text-xs opacity-80">                    Nota: la línea punteada marca un objetivo estimado para el próximo cierre.                  </div>                )}                </>              ) : (                <div className="rounded-xl border border-amber-400/30 bg-amber-500/10 p-4 text-amber-200">                  <div className="font-semibold">Falta símbolo</div>                  <div className="text-sm opacity-80">                    Selecciona un activo (o verifica que <code>current.symbol</code> / <code>focus</code> estén poblados).                  </div>                </div>              )}            </div>          </div>          <aside className="space-y-3">            <div className="card p-4">              <div className="text-sm opacity-80 mb-2">Acciones rápidas</div>              <div className="flex flex-wrap gap-2">                <button className="btn" onClick={() => router.push("/simulator")}>Probar inversión</button>                <button className="btn" onClick={() => router.push("/invest/request")}>Enviar solicitud</button>                <button className="btn" onClick={() => router.push("/profile")}>Mi perfil</button>              </div>            </div>            <div className="card p-4">              <div className="text-sm opacity-80 mb-2">Actualización</div>              <div className="text-xs opacity-70">                {updatedAt ? `Último refresco: ${updatedAt.toLocaleTimeString()}` : "Cargando…"}              </div>            </div>          </aside>        </section>        {/* Lista agrupada por clase */}        <section className="space-y-5">          {error && (            <div className="sm:col-span-2 lg:col-span-3 p-4 rounded-xl border border-rose-500/30 bg-rose-500/10 text-rose-200">              {error}            </div>          )}          {!feed && !error && (            <>              <div className="card p-4 h-28 animate-pulse" />              <div className="card p-4 h-28 animate-pulse" />              <div className="card p-4 h-28 animate-pulse" />            </>          )}          {feed && (() => {            const items = feed.filter((it) => it.symbol !== current?.symbol);            const order: Array<AssetClass> = ['crypto','equity','etf','forex','index','other'];            const groups = new Map<AssetClass, typeof items>();            for (const it of items) {              const cls = classifySymbol(it.symbol) as AssetClass;              if (filterClass !== 'all' && cls !== filterClass) continue;              const arr = groups.get(cls) ?? []; arr.push(it); groups.set(cls, arr);            }            return order              .filter((cls) => groups.get(cls)?.length)              .map((cls) => (                <div key={cls} className="space-y-3">                  <div className="flex items-center gap-2">                    <div className="text-sm uppercase tracking-wide opacity-70">{cls === 'crypto' ? 'Cripto' : cls === 'equity' ? 'Acciones' : cls === 'etf' ? 'ETF' : cls === 'forex' ? 'Forex' : cls === 'index' ? 'Índices' : 'Otros'}</div>                    <div className="h-px flex-1 bg-white/10" />                  </div>                  <div className="grid sm:grid-cols-2 lg:grid-cols-3 gap-4">                    {groups.get(cls)!.map((it) => {                      const conf = it.p_conf != null ? Math.round(it.p_conf * 100) : 0;                      const pinnedNow = pinned.includes(it.symbol);                      const meta = getAssetMeta(it.symbol);                      return (                        <button                          key={it.symbol}                          className={`card p-4 text-left transition ${current?.symbol === it.symbol ? "ring-2 ring-[--ring]" : "hover:bg-white/10"}`}                          onClick={() => {                            setFocus(it.symbol);                            if (!pinnedNow) setPinned((p) => [it.symbol, ...p].slice(0, 6));                          }}                        >                          <div className="flex items-center justify-between">                            <div className="font-semibold flex items-center gap-2">                              <SymbolAvatar symbol={it.symbol} size={16} />                              <span>{it.symbol}</span>                            </div>                            <span className="chip">{actionLabel(it.action)}</span>                          </div>                          {meta && (                            <div className="mt-1 text-xs opacity-75">{meta.name}</div>                          )}                          <div className="mt-2 flex items-center gap-2 text-sm opacity-80">                            <span>{horizonLabel((it.horizon as Horizon) || "1d")}</span>                            <span>·</span>                            <span>{conf}% certeza</span>                          </div>                          <div className="mt-3 flex items-center gap-2">                            <span                              className={`text-xs px-2 py-0.5 rounded-full border ${pinnedNow ? "bg-[--primary] text-white border-transparent" : "bg-white/10 border-white/15"}`}                              onClick={(e) => { e.stopPropagation(); togglePin(it.symbol); }}                            >                              {pinnedNow ? "Fijado" : "Fijar"}                            </span>                            {it.stops?.tp != null && it.stops?.sl != null && (                              <span className="text-xs opacity-70">con protecciones</span>                            )}                          </div>                        </button>                      );                    })}                  </div>                </div>              ));          })()}              const conf = it.p_conf != null ? Math.round(it.p_conf * 100) : 0;        {showHelp && feed && (          <div className="text-xs opacity-70">Sugerencia: usa &quot;Fijar&quot; para tener a mano tus activos favoritos arriba del todo.</div>        )}      </div>    </main>  );}
// src/app/(authed)/home/page.tsx
"use client";

import { useEffect, useMemo, useState } from "react";
import { useRouter } from "next/navigation";
import { loadRiskProfile } from "@/lib/invest";
import MarketChartE from "@/components/MarketChartE";
import PriceTicker from "@/components/PriceTicker";
import SymbolAvatar from "@/components/SymbolAvatar";
import AssetHover from "@/components/AssetHover";
import { classifySymbol, type AssetClass } from "@/lib/market";
import { getAssetMeta } from "@/lib/assets.meta";

type Horizon = "1d" | "1w";
type Action = "BUY" | "SELL" | "HOLD" | "ABSTAIN";

type FeedItem = {
  symbol: string;
  ts?: string;
  action: Action;
  p_conf?: number;
  sigma?: number;
  horizon?: string;
  last_close?: number;
  stops?: { tp: number; sl: number } | null;
  quality?: number;
};

const API_BASE = (process.env.NEXT_PUBLIC_API_BASE || "").replace(/\/+$/, "");

function actionLabel(a: Action) {
  if (a === "BUY") return "Sube";
  if (a === "SELL") return "Baja";
  if (a === "HOLD") return "En espera";
  return "Sin señal clara";
}
function horizonLabel(h: Horizon) {
  return h === "1w" ? "Próximas semanas" : "Próximos días";
}

async function fetchJSON<T>(url: string, init?: RequestInit): Promise<T> {
  const r = await fetch(url, { ...init, cache: "no-store" });
  if (!r.ok) throw new Error(`HTTP ${r.status}`);
  return (await r.json()) as T;
}

async function getFeed(h: Horizon, minConf: number): Promise<FeedItem[]> {
  if (!API_BASE) return [];
  const qs = new URLSearchParams({ horizon: h, min_conf: String(minConf), limit: "200" });
  const data = await fetchJSON<unknown>(`${API_BASE}/v1/feed?${qs.toString()}`);
  if (!Array.isArray(data)) return [];
  return data
    .map((x) => {
      const o = x as Record<string, unknown>;
      return {
        symbol: String(o.symbol ?? ""),
        ts: typeof o.ts === "string" ? o.ts : undefined,
        action: (["BUY", "SELL", "HOLD", "ABSTAIN"].includes(String(o.action)) ? String(o.action) : "HOLD") as Action,
        p_conf: typeof o.p_conf === "number" ? o.p_conf : undefined,
        sigma: typeof o.sigma === "number" ? o.sigma : undefined,
        horizon: typeof o.horizon === "string" ? o.horizon : undefined,
        last_close: typeof o.last_close === "number" ? o.last_close : undefined,
        stops: (
          typeof o.stops === "object" && o.stops !== null &&
          typeof (o.stops as { tp?: unknown }).tp === "number" &&
          typeof (o.stops as { sl?: unknown }).sl === "number"
        )
          ? { tp: (o.stops as { tp: number }).tp, sl: (o.stops as { sl: number }).sl }
          : null,
        quality: typeof o.quality === "number" ? o.quality : undefined,
      } satisfies FeedItem;
    })
    .filter((x) => x.symbol);
}

export default function HomePage() {
  const router = useRouter();

  const defaults = useMemo(() => {
    const p = loadRiskProfile()?.profile;
    if (p === "Conservador") return { horizon: "1d" as Horizon, minConf: 0.65 };
    if (p === "Agresivo") return { horizon: "1d" as Horizon, minConf: 0.55 };
    return { horizon: "1d" as Horizon, minConf: 0.60 };
  }, []);

  const [horizon, setHorizon] = useState<Horizon>(defaults.horizon);
  const [minConf, setMinConf] = useState<number>(defaults.minConf);
  const [feed, setFeed] = useState<FeedItem[] | null>(null);
  const [error, setError] = useState<string | null>(null);
  const [updatedAt, setUpdatedAt] = useState<Date | null>(null);
  const [pinned, setPinned] = useState<string[]>([]);
  const [focus, setFocus] = useState<string | null>(null);
  const [showHelp] = useState<boolean>(true);
  const [filterClass, setFilterClass] = useState<AssetClass | 'all'>("all");
  const [rangeDelta, setRangeDelta] = useState<number | null>(null);
  const [lastPrice, setLastPrice] = useState<number | null>(null);
  const [refreshKey, setRefreshKey] = useState<number>(0);

  // Refresca al volver a la pestaña o enfocar la ventana (re-monta chart y ticker)
  useEffect(() => {
    const onFocus = () => setRefreshKey((k) => k + 1);
    const onVisible = () => { if (document.visibilityState === 'visible') setRefreshKey((k) => k + 1); };
    window.addEventListener('focus', onFocus);
    document.addEventListener('visibilitychange', onVisible);
    return () => { window.removeEventListener('focus', onFocus); document.removeEventListener('visibilitychange', onVisible); };
  }, []);

  useEffect(() => {
    let alive = true;
    async function load() {
      try {
        setError(null);
        const data = await getFeed(horizon, minConf);
        if (!alive) return;
        setFeed(data);
        setUpdatedAt(new Date());

        if (!focus) {
          const fav = (() => { try { return localStorage.getItem('aura_favorite_asset'); } catch { return null; } })();
          if (fav) {
            setFocus(fav);
            setPinned((p) => (p.includes(fav) ? p : [fav, ...p].slice(0, 6)));
          } else {
            const best = data.filter(d => d.action !== 'ABSTAIN').sort((a,b) => (b.p_conf ?? 0) - (a.p_conf ?? 0))[0];
            if (best) {
              setFocus(best.symbol);
              setPinned((p) => (p.includes(best.symbol) ? p : [best.symbol, ...p].slice(0, 6)));
            }
          }
        }
      } catch (e) {
        setError(e instanceof Error ? e.message : 'No se pudo cargar el feed');
      }
    }
    void load();
    const id = setInterval(load, 90_000);
    return () => { alive = false; clearInterval(id); };
  }, [horizon, minConf, focus]);

  useEffect(() => {
    try {
      const pref = localStorage.getItem('aura_pref_class') as (AssetClass | 'all') | null;
      if (pref) setFilterClass(pref);
    } catch { /* noop */ }
  }, []);

  const current = useMemo(() => {
    if (!feed || !focus) return null;
    return feed.find((x) => x.symbol === focus) ?? null;
  }, [feed, focus]);
  const assetSymbol = current?.symbol ?? focus ?? null;
  const confPct = current?.p_conf != null ? Math.round(current.p_conf * 100) : null;
  const selectedMeta = useMemo(() => (assetSymbol ? getAssetMeta(assetSymbol) : null), [assetSymbol]);

  function togglePin(sym: string) {
    setPinned((p) => (p.includes(sym) ? p.filter((s) => s !== sym) : [sym, ...p].slice(0, 6)));
  }

  // Cuando cambia el símbolo, resetea precio/rango para evitar desfasajes visuales
  useEffect(() => {
    setLastPrice(null);
    setRangeDelta(null);
  }, [assetSymbol]);

  return (
    <main className="min-h-dvh bg-background text-foreground">
      <div className="max-w-6xl mx-auto px-3 sm:px-6 py-5 sm:py-8 space-y-6 sm:space-y-8">
        <header className="flex flex-wrap items-center gap-4 justify-between">
          <div>
            <h1 className="text-3xl font-bold tracking-tight">Para ti</h1>
            <p className="text-sm opacity-70">Las mejores recomendaciones, ordenadas para tu perfil.</p>
          </div>
          <div className="flex items-center gap-2">
            <select value={horizon} onChange={(e) => setHorizon(e.target.value as Horizon)} className="toolbar" title="Periodo">
              <option value="1d">Próximo cierre (1 día)</option>
              <option value="1w">Próximas semanas</option>
            </select>

            <div className="toolbar">
              <label className="text-xs opacity-80 mr-2">Certeza mínima</label>
              <input type="range" min={10} max={80} value={Math.round(minConf * 100)} onChange={(e) => setMinConf(Number(e.target.value) / 100)} />
              <span className="ml-2 text-xs font-medium">{Math.round(minConf * 100)}%</span>
            </div>

            <div className="toolbar">
              <label className="text-xs opacity-80 mr-2">Clase</label>
              <select value={filterClass} onChange={(e) => setFilterClass(e.currentTarget.value as AssetClass | 'all')} className="bg-transparent">
                <option value="all">Todas</option>
                <option value="crypto">Cripto</option>
                <option value="forex">Forex</option>
                <option value="equity">Acciones</option>
                <option value="etf">ETF</option>
                <option value="index">Índices</option>
              </select>
              {filterClass !== 'all' && (
                <button className="ml-2 btn" onClick={() => setFilterClass('all')} title="Quitar filtro">Quitar filtro</button>
              )}
            </div>

            <button className="btn" onClick={() => router.push("/feed")}>Ver todo</button>
          </div>
        </header>

        <section className="grid lg:grid-cols-3 gap-5">
          <div className="lg:col-span-2">
            <div className="card p-4">
              <div className="flex items-center justify-between mb-3">
                <div className="flex items-center gap-3">
                  <div className="text-2xl font-semibold flex items-center gap-2">
                    {assetSymbol ? (
                      <SymbolAvatar symbol={assetSymbol} size={28} />
                    ) : ("-")}
                  </div>
                  <PriceTicker key={`pt-${assetSymbol ?? '-' }-${refreshKey}`} symbol={assetSymbol ?? undefined} symbolMode="plain" hover={false} price={lastPrice} deltaPct={rangeDelta ?? null} className="ml-2" updateEveryMs={3000} />
                  {assetSymbol && (
                    <AssetHover symbol={assetSymbol}><span className="info-badge">i</span></AssetHover>
                  )}
                  {current && <span className="chip">{actionLabel(current.action)}</span>}
                  {confPct != null && <span className="chip">{confPct}% certeza</span>}
                  {current?.horizon && (
                    <span className="chip">{horizonLabel((current.horizon as Horizon) || "1d")}</span>
                  )}
                </div>
              </div>
              {selectedMeta && (
                <div className="text-xs opacity-75 mb-2">{selectedMeta.name}</div>
              )}

              {assetSymbol ? (
                <>
                  <MarketChartE
                    key={`mc-${assetSymbol}-${refreshKey}`}
                    symbol={assetSymbol}
                    provider="auto"
                    tf="5m"
                    height={440}
                    baseline={null}
                    showLastPrice
                    onPrice={setLastPrice}
                    onRangeDelta={(d: number) => setRangeDelta(d)}
                  />
                </>
              ) : (
                <div className="rounded-xl border border-amber-400/30 bg-amber-500/10 p-4 text-amber-200">
                  <div className="font-semibold">Falta símbolo</div>
                  <div className="text-sm opacity-80">Selecciona un activo.</div>
                </div>
              )}
            </div>
          </div>

          <aside className="space-y-3">
            <div className="card p-4">
              <div className="text-sm opacity-80 mb-2">Acciones rápidas</div>
              <div className="flex flex-wrap gap-2">
                <button className="btn" onClick={() => router.push("/simulator")}>Probar inversión</button>
                <button className="btn" onClick={() => router.push("/invest/request")}>Enviar solicitud</button>
                <button className="btn" onClick={() => router.push("/profile")}>Mi perfil</button>
              </div>
            </div>

            <div className="card p-4">
              <div className="text-sm opacity-80 mb-2">Actualización</div>
              <div className="text-xs opacity-70">{updatedAt ? `Último refresco: ${updatedAt.toLocaleTimeString()}` : "Cargando."}</div>
            </div>
          </aside>
        </section>

        {/* Lista agrupada por clase */}
        <section className="space-y-5">
          {error && (
            <div className="p-4 rounded-xl border border-rose-500/30 bg-rose-500/10 text-rose-200">{error}</div>
          )}

          {!feed && !error && (
            <>
              <div className="card p-4 h-28 animate-pulse" />
              <div className="card p-4 h-28 animate-pulse" />
              <div className="card p-4 h-28 animate-pulse" />
            </>
          )}

          {feed && (() => {
            const items = feed.filter((it) => it.symbol !== current?.symbol);
            const order: AssetClass[] = ["crypto", "equity", "etf", "forex", "index", "other"];
            const groups = new Map<AssetClass, FeedItem[]>();
            for (const it of items) {
              const cls = classifySymbol(it.symbol) as AssetClass;
              if (filterClass !== 'all' && cls !== filterClass) continue;
              const arr = groups.get(cls) ?? [];
              arr.push(it); groups.set(cls, arr);
            }
            return order
              .filter((cls) => (groups.get(cls)?.length ?? 0) > 0)
              .map((cls) => (
                <div key={cls} className="space-y-3">
                  <div className="flex items-center gap-2">
                    <div className="text-sm uppercase tracking-wide opacity-70">{cls === 'crypto' ? 'Cripto' : cls === 'equity' ? 'Acciones' : cls === 'etf' ? 'ETF' : cls === 'forex' ? 'Forex' : cls === 'index' ? 'Índices' : 'Otros'}</div>
                    <div className="h-px flex-1 bg-white/10" />
                  </div>
                  <div className="grid sm:grid-cols-2 lg:grid-cols-3 gap-4">
                    {groups.get(cls)!.map((row) => {
                      const conf = row.p_conf != null ? Math.round(row.p_conf * 100) : 0;
                      const pinnedNow = pinned.includes(row.symbol);
                      const meta = getAssetMeta(row.symbol);
                      return (
                        <button
                          key={row.symbol}
                          className={`card p-4 text-left transition ${current?.symbol === row.symbol ? "ring-2 ring-[--ring]" : "hover:bg-white/10"}`}
                          onClick={() => {
                            setFocus(row.symbol);
                            if (!pinnedNow) setPinned((p) => [row.symbol, ...p].slice(0, 6));
                          }}
                        >
                          <div className="flex items-center justify-between">
                            <div className="font-semibold flex items-center gap-2">
                              <SymbolAvatar symbol={row.symbol} size={18} />
                              <AssetHover symbol={row.symbol}><span>{row.symbol}</span></AssetHover>
                            </div>
                            <span className="chip">{actionLabel(row.action)}</span>
                          </div>
                          {meta && (
                            <div className="mt-1 text-xs opacity-75">{meta.name}</div>
                          )}
                          <div className="mt-2 flex items-center gap-2 text-sm opacity-80">
                            <span>{horizonLabel((row.horizon as Horizon) || "1d")}</span>
                            <span>•</span>
                            <span>{conf}% certeza</span>
                          </div>
                          <div className="mt-3 flex items-center gap-2">
                            <span
                              className={`text-xs px-2 py-0.5 rounded-full border ${pinnedNow ? "bg-[--primary] text-white border-transparent" : "bg-white/10 border-white/15"}`}
                              onClick={(e) => { e.stopPropagation(); togglePin(row.symbol); }}
                            >
                              {pinnedNow ? "Fijado" : "Fijar"}
                            </span>
                            {row.stops?.tp != null && row.stops?.sl != null && (
                              <span className="text-xs opacity-70">con protecciones</span>
                            )}
                          </div>
                        </button>
                      );
                    })}
                  </div>
                </div>
              ));
          })()}
        </section>

        {showHelp && feed && (
          <div className="text-xs opacity-70">Sugerencia: usa &quot;Fijar&quot; para tener a mano tus activos favoritos arriba del todo.</div>
        )}
      </div>
    </main>
  );
}

